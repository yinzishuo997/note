## chp16

### 非类型模板实参

* 一个非类型实参可以是一个整型, 或者是一个指向对象或函数的指针或引用.绑定到非类型整型参数的实参必须是一个常量表达式.绑定到指针或引用非类型参数的实参必须具有静态的生存期.我们不能用一个普通(非static)局部变量或动态对象作为指针或引用非类型模板参数的实参.指针也可以用 nullptr 或一个值为0的常量表达式来实例化.

### 类模板成员函数的实例化

* 如果一个成员函数没有被使用, 则它不会被实例化.成员函数只有在被用到时才进行实例化,这一特性使得即使某种类型不能完全符合模板操作的要求, 我们仍然能用该类型实例化类.

### 实例化定义会实例化所有成员

* 一个类模板的实例化定义会实例化该模板的所有成员, 包括内联函数.

### 类型转换与模板类型参数

* 顶层 const 无论是在形参中还是在实参中, 都会被忽略.
* const 转换
* 数组或函数指针转换. (如果函数形参不是引用类型)
* 其他类型转换, 如算数转换, 派生类向基类的转换, 以及用户定义的转换 都不能应用于函数模板.

### 函数模板显示实参

* 对于模板类型参数已经显示指定了的函数实参, 也进行正常的类型转换. 

### 函数指针和实参推断

* 当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时, 编译器将使用指针的类型来推断模板实参.

### 引用折叠和右值引用参数

* 当我们将一个左值传递给函数的右值引用参数时, 且此右值引用指向模板类型参数时, 编译器推断模板类型参数为实参的左值引用类型.
* 对于一个给的那个类型 x:
    * x& &, x& && 和 x&& & 都折叠成x&
    * x&& && 折叠成 x&&
* 如果函数一个参数是一个指向模板类型参数的右值引用, 则它可以被绑定到一个左值.
    * 且 : 如果实参是一个左值, 则推断出来的模板实参类型将是一个左值引用, 且函数参数将被实例化为一个普通的左值引用参数.
* 我们可以将任意类型的实参传递给 ``T&&`` 类型的函数参数.

``` cpp
template <typename T> void f(T&&);          // 非 const 右值
template <typename T> void f(const T&);     // 左值和 const 右值
```

